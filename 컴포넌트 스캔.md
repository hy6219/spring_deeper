# 컴포넌트 스캔

## 1. 컴포넌트 스캔과 자동주입 시작하기

- `@ComponentScan` 을 설정정보 파일에 붙여주면 되고, `@Bean` 메서드를 적어주지 않아도 됨
- `@ComponentScan` : `@Component` 어노테이션이 붙은 클래스를 스캔해서 빈으로 등록
		- 빈 이름 기본 전략 : 클래스 명의 맨 앞글자만 소문자로 변경하여 사용
		- 빈 이름 직접 지정 : `@Component("abc")` 와 같이 지정

- `@Configuration` 도 코드를 열어보면, `@Component`가 있어서 스캔된 것
- `@ComponentScan( excludeFilters = @ComponentScan.Filter` : 특정 부분은 사전에 스프링에 등록하지 않도록 안내

```java
@ComponentScan(  
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)  
)
```

이 부분은 기존의 AppConfig 와 충돌하지 않도록 하기 위한 부분!

- 자동의존관계 주입

(예시) - 생성자 메서드 위에 붙이기

```java
@Autowired  
public MemberServiceImpl(MemberRepository memberRepository) {  
    this.memberRepository = memberRepository;  
}
```

> 생성자 인자가 스프링 빈으로 등록되어 있는지 확인 후 스프링 빈 생성
> 생성자에서 의존관계도 한번에 주입받을 수 있음

```java
package hello.core;  
  
import hello.core.member.MemberService;  
import org.junit.jupiter.api.Test;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
  
import static org.assertj.core.api.Assertions.assertThat;  
  
class AutoAppConfigTest {  
  
    @Test  
  void basicScan() {  
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AutoAppConfig.class);  
        MemberService memberService = context.getBean(MemberService.class);  
        assertThat(memberService).isInstanceOf(MemberService.class);  
    }  
}
```

필요한 서비스, 레포지토리에 `@ComponentScan`, `@Autowired`을 달아주고 위의 테스트를 진행하면 

```
Creating shared instance of singleton bean 'autoAppConfig'
...
Autowiring by type from bean name 'memberServiceImpl' via constructor to bean named 'memoryMemberRepository'
```

위와 같이 싱글톤 방식으로 생성되는 빈, 빈 내부에서 자동주입되는 빈을 확인해볼 수 있다

✅ Autowired 의존관계 자동 주입

- 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입
- 기본조회전략 : ~ApplicationContext.getBean(...) 과 동일

## 2. 탐색 위치와 기본 스캔 대상

1. 탐색할 패키지의 시작 위치 지정

- `@ComponentScan(basePackages = "...")`

```java
package hello.core;  
  
import org.springframework.context.annotation.ComponentScan;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.context.annotation.FilterType;  
  
@Configuration  
@ComponentScan(  
        basePackages = "hello.core",  
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)  
)  
public class AutoAppConfig {  
}
```
- `@ComponentScan(basePackageClasses = "...")` : 지정한 클래스의 패키지가 시작위치가  됨
```java
package hello.core;  
  
import org.springframework.context.annotation.ComponentScan;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.context.annotation.FilterType;  
  
@Configuration  
@ComponentScan(  
        basePackages = "hello.core",  
        basePackageClasses = AutoAppConfig.class,  
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)  
)  
public class AutoAppConfig {  
}
```
		▶ AutoAppConfig가 속해있는 패키지인 hello.core가 시작위치가 됨


- `@ComponentScan` 옵션으로 basePackages 나 basePackageClasses 옵션을 주지 않고 사용하는, default 상태에서는 `@ComponentScan이 붙은 클래스의 패키지 및 그 하위 패키지` 에 대해서 스캔을 진행

▶ 권장!!
(스프링 부트의 경우,  스프링 부트 대표 시작 정보인 `@SpringBootApplication` 에 `@ComponentScan`이 들어가 있어서 생략될 수 있음)

```java
package hello.core;  
  
import org.springframework.context.annotation.ComponentScan;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.context.annotation.FilterType;  
  
@Configuration  
@ComponentScan(  
      /*  basePackages = "hello.core",  
 basePackageClasses = AutoAppConfig.class,*/  excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)  
)  
public class AutoAppConfig {  
}
```

2. 컴포넌트 스캔의 기본 대상

** `@ComponentScan`의 `useDefaultFilters` 옵션은 기본적으로 켜져 있는데, 이 옵션을 끄면, 기본 스캔 대상들이 제외됨  

```java
boolean useDefaultFilters() default true;
```

- `@Component` : 컴포넌트 스캔에서 사용
- `@Controller` : 스프링 MVC 컨트롤러에서 사용
			- 스프링 MVC 컨트롤러로 인식
- `@Service` : 스프링 MVC 서비스에서 사용
			- 스프링에서 특별한 처리를 하지는 않고, 단지 개발자의 입장에서 여기에 핵심 비즈니스 로직이 있을 것으로 생각해볼 수 있게 도와줄 수 있음
- `@Repository` : 스프링 MVC 레포지토리에서 사용
			- 스프링 데이터 접근 계층으로 인식하고 , 데이터 계층의 예외를 스프링 예외로 변환해줌
- `@Configuration` : 스프링 설정정보에서 사용
			- 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤 방식을 유지하도록 추가처리를 진행해줌

```java
@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
@Component  
public @interface Service {  
  @AliasFor(annotation = Component.class)  
   String value() default "";  
  
}
```
▶ Service 어노테이션을 들여다보아도, `@Component`가 들어가 있는 것을 확인해볼 수 있는데, `어노테이션은 상속의 개념이 없다` 
그래서 이렇게 특정 어노테이션 내부에 다른 어노테이션이 들어가 있는 것은 자바가 아닌 스프링에서 지원하는 기능이다



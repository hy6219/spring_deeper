# 스프링 컨테이너와 스프링 빈

## 1. 스프링 컨테이너 생성

```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);  
MemberService memberService = applicationContext.getBean("memberService",MemberService.class);  
OrderService orderService = applicationContext.getBean("orderService",OrderService.class);
```

- `ApplicationContext` = `스프링 컨테이너` 이자 `인터페이스`
- AnnotationConfigApplicationContext 는 ApplicationContext를 구현한 구현체 중 하나일 뿐
- 스프링 컨테이너는 `xml 기반` /`어노테이션 기반의 자바 설정 클래스` 로 만들 수 있음
		- 최근은 어노테이션 기반으로 많이 만들고 있음

![](data:image/png;base64,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)

- 스프링 컨테이너 생성 시에는 구성 정보를 지정해주어야 함
- 컨테이너 내부에는 빈 이름을 key, 빈 객체를 value로 매핑하여 구성정보를 갖추고 있음

![스프링 빈 등록](https://velog.velcdn.com/images%2Fwoply%2Fpost%2F9bb1492d-1415-4077-a533-878444cb91bb%2Fimage.png)

- 파라미터로 넘어온 구성 정보 클래스를 기반으로 `@Bean`  혹은 `@Bean(name = 내 입맛대로 빈 이름 지정)` 으로 지정해둔 메서드를 활용해서 빈 객체를 등록

⚠ ** 빈 이름은 항상 다른 이름을 부여 ** 해야 함!!
( 같은 이름일 경우, 다른 빈이 무시되거나, 기존 빈을 덮어버리거나, 설정에 따라 오류가 발생할 수 있음 )
( 스프링 부트는 겹쳐지면 튕겨내는 것이 디폴트로 되어 있음 )

![스프링 빈 의존관계 설정 ](https://velog.velcdn.com/images%2Fwoply%2Fpost%2F52670185-81c9-469d-92b3-3862a5251753%2Fimage.png)

- 의존 관계를 주입해줌
- 단순 자바 코드를 호출하는 것 같지만, 이 차이는 싱글톤 컨테이너에서 존재함! ( 추후 정리 )


+ 스프링은 `빈 생성` 과 `의존관계 주입 단계` 가 분리되어 있음
+ 이렇게 자바코드로 구성 정보를 설정해주면, 이 두 단계가 동시에 처리되는데, 이는 이해를 돕기 위한 부분이므로 참고만 하자(개념적으로) (실제로 이렇게 동시에 처리되는 경우가 있기도 함)

## 2. 컨테이너에 등록된 모든 빈 조회

```java
package hello.core.beanfind;  
  
import hello.core.AppConfig;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.config.BeanDefinition;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
  
public class ApplicationContextInfoTest {  
  
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);  
  
  @Test  
 @DisplayName("모든 빈 출력하기")  
    void findAllBean() {  
        //junit5부터는 테스트 메서드의 접근제한자가 public이 아니어도 됨  
  String[] beanDefinitionNames = ac.getBeanDefinitionNames();  
  //iter 엔터 - 리스트/배열에 대해서 for문이 자동으로 생성됨  
  for (String beanDefinitionName : beanDefinitionNames) {  
            Object bean = ac.getBean(beanDefinitionName);  
  System.out.println("name = " + beanDefinitionName + ", object = " + bean);  
  }  
    }  
  
  
    @Test  
 @DisplayName("애플리케이션 빈 출력하기")  
    void findApplicationBean() {  
        //junit5부터는 테스트 메서드의 접근제한자가 public이 아니어도 됨  
  String[] beanDefinitionNames = ac.getBeanDefinitionNames();  
  //iter 엔터 - 리스트/배열에 대해서 for문이 자동으로 생성됨  
  for (String beanDefinitionName : beanDefinitionNames) {  
            BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);  
  
  //스프링 내부 기반 빈이 아닌, 개발을 위해 등록해둔 빈들을 가져오기  
  if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION){  
                Object bean = ac.getBean(beanDefinitionName);  
  System.out.println("name = " + beanDefinitionName + ", object = " + bean);  
  }  
        }  
    }  
}
```
- `ApplicationContext.getBeanDefinitionNames()` : `스프링에 등록된 모든 빈 이름 조회`
- `ApplicationContext.getBean()` : `빈 이름으로 빈 객체 조회`
- `ApplicationContext.getRole()` : 애플리케이션 내부 빈과 직접 등록한 빈을 구분
- Role ROLE_APPLICATION :  직접 등록한 애플리케이션 빈
- Role ROLE_INFRASTRUCTURE :  스프링이 내부에서 사용하는 빈

### 2-1. 스프링 빈 조회 - 기본

- `applicationContext.getBean(빈이름, 타입)`
- `applicationContext.getBean(타입)`
- 조회 대상 스프링 빈이 없으면 `NoSuchBeanDefinitionException : No bean named 'xxxxx' available`  예외 발생
- 인터페이스로 조회하게 되면, 인터페이스의 구현체가 조회됨
- 타입을 구현체로 조회해도 빈 객체 조회가 가능함(이 부분은 비권장! 이유는 역할과 구현을 구분하고, 역할에 의존해야 하기 때문)(이 경우는 구현에 의존하기 때문에 비권장)
```java
package hello.core.beanfind;  
  
import hello.core.AppConfig;  
import hello.core.member.MemberService;  
import hello.core.member.MemberServiceImpl;  
import org.assertj.core.api.Assertions;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.NoSuchBeanDefinitionException;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
  
import static org.junit.jupiter.api.Assertions.assertThrows;  
  
public class ApplicationContextBasicFindTest {  
  
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);  
  
  @Test  
 @DisplayName("빈 이름으로 조회")  
    void findBeanByName() {  
        MemberService memberService = ac.getBean("memberService", MemberService.class);  
//        System.out.println("memberService= "+memberService);  
//        System.out.println("memberService.getClass() = "+memberService.getClass());  
  Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);  
  }  
  
    @Test  
 @DisplayName("이름없이 타입으로만 조회")  
    void findBeanByType() {  
        MemberService memberService = ac.getBean(MemberService.class);  
//        System.out.println("memberService= "+memberService);  
//        System.out.println("memberService.getClass() = "+memberService.getClass());  
  Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);  
  }  
  
    @Test  
 @DisplayName("구현체 타입으로 조회")  
    void findBeanByName2() {  
        MemberService memberService = ac.getBean("memberService", MemberServiceImpl.class);  
//        System.out.println("memberService= "+memberService);  
//        System.out.println("memberService.getClass() = "+memberService.getClass());  
  Assertions.assertThat(memberService).isInstanceOf(MemberServiceImpl.class);  
  }  
  
    @Test  
 @DisplayName("빈 이름으로 조회X")  
    void findBeanByNameX() {  
        assertThrows(NoSuchBeanDefinitionException.class, () -> ac.getBean("xxxxx", MemberService.class));  
  }  
  
}
```

### 2-2. 스프링 빈 조회 - 동일한 타입이 둘 이상

- 타입으로 조회할 경우, 같은 타입의 스프링 빈이 둘 이상일 경우 오류가 발생
		- 이 경우, `빈 이름을 지정` 하기
```
NoUniqueBeanDefinitionException: No qualifying bean of type 'hello.core.member.MemberRepository' available: expected single matching bean but found 2: memberRepository1,memberRepository2
```

- `applicationContext.getBeansOfType()` 을 사용하면 모든 빈 조회 가능

```java
package hello.core.beanfind;  
  
import hello.core.member.MemberRepository;  
import hello.core.member.MemoryMemberRepository;  
import org.assertj.core.api.Assertions;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
  
import java.util.Map;  
  
import static org.junit.jupiter.api.Assertions.assertThrows;  
  
public class ApplicationContextSameBeanFindTest {  
  
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class);  
  
  @Test  
 @DisplayName("같은 타입의 빈이 두 개 이상일 때 중복 오류 발생")  
    void findBeanByTypeDuplicate() {  
        /*  
 NoUniqueBeanDefinitionException: No qualifying bean of type 'hello.core.member.MemberRepository' available: expected single matching bean but found 2: memberRepository1,memberRepository2 */  assertThrows(NoUniqueBeanDefinitionException.class, () -> ac.getBean(MemberRepository.class));  
  }  
  
    @Test  
 @DisplayName("타입으로 조회 시 같은 타입이 둘 이상 있으면 빈 이름을 지정하면 된다")  
    void findBeanByName(){  
        MemberRepository memberRepository1 = ac.getBean("memberRepository1", MemberRepository.class);  
  Assertions.assertThat(memberRepository1).isInstanceOf(MemberRepository.class);  
  }  
  
    //ctrl+shift+enter: 코드 컴플리션으로 개행됨  
  @Test  
 @DisplayName("특정 타입을 모두 조회하기")  
    void findAllBeanByType(){  
        Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);  
 for (String key : beansOfType.keySet()) {  
            System.out.println("key = "+key+", value= "+beansOfType.get(key));  
  }  
        System.out.println("beansOfType= "+beansOfType);  
  Assertions.assertThat(beansOfType.size()).isEqualTo(2);  
  }  
  
    @Configuration  
  static class SameBeanConfig {  
        @Bean  
  public MemberRepository memberRepository1() {  
            return new MemoryMemberRepository();  
  }  
  
        @Bean  
  public MemberRepository memberRepository2() {  
            return new MemoryMemberRepository();  
  }  
    }  
}
```

### 2-3. 스프링 빈 조회 - 상속관계

- 부모타입으로 조회하면, 자식타입도 함께 조회 ▶ 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면, 모든 스프링 빈을 조회하게 됨

```java
package hello.core.beanfind;  
  
import hello.core.discount.DiscountPolicy;  
import hello.core.discount.FixDiscountPolicy;  
import hello.core.discount.RateDiscountPolicy;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
  
import java.util.Map;  
  
import static org.assertj.core.api.Assertions.assertThat;  
import static org.junit.jupiter.api.Assertions.assertThrows;  
  
public class ApplicationContextExtendsFindTest {  
  
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);  
  
  @Test  
 @DisplayName("부모 타입으로 조회 시, 자식이 둘 이상 존재하면 중복 오류가 발생")  
    void findBeanByParentTypeDuplicate() {  
        assertThrows(NoUniqueBeanDefinitionException.class, () -> ac.getBean(DiscountPolicy.class));  
  }  
  
    @Test  
 @DisplayName("부모 타입으로 조회 시, 자식이 둘 이상 존재하면 빈 이름을 지정하면 됨")  
    void findBeanByParentTypeBeanName(){  
        DiscountPolicy rateDiscountPolicy = ac.getBean("rateDiscountPolicy", DiscountPolicy.class);  
  assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);  
  }  
  
    @Test  
 @DisplayName("(비권장-구현에 의존) 특정 하위 타입으로 조회")  
    void findBeanBySubType(){  
        RateDiscountPolicy rateDiscountPolicy = ac.getBean(RateDiscountPolicy.class);  
  assertThat(rateDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);  
  }  
  
    @Test  
 @DisplayName("부모 타입으로 모든 빈 조회")  
    void findAllBeanByParentType(){  
        Map<String, DiscountPolicy> beansOfType = ac.getBeansOfType(DiscountPolicy.class);  
  assertThat(beansOfType.size()).isEqualTo(2);  
  
 for (String key : beansOfType.keySet()) {  
            System.out.println("key = "+key+", value= "+beansOfType.get(key));//테스트에서는 자동으로 성패를 결정시켜야 해서 출력은 비권장!  
  }  
    }  
  
    @Test  
 @DisplayName("부모 타입으로 모든 빈 조회하기 - Object")  
    void findAllBeanByObjectType(){  
        Map<String, Object> beansOfType = ac.getBeansOfType(Object.class);  
 for (String key : beansOfType.keySet()) {  
            System.out.println(" key = "+key+", value= "+beansOfType.get(key));//테스트에서는 자동으로 성패를 결정시켜야 해서 출력은 비권장!  
  }  
    }  
  
    @Configuration  
  static class TestConfig {  
        @Bean  
  public DiscountPolicy rateDiscountPolicy() {  
            /*  
  메서드 리턴타입이 부모타입인 이유 : 구현과 역할을 분리하기 위함  
 역할인 DiscountPolicy에 의존하게 하기 위함  
 [구현은 구현체]  
 */  return new RateDiscountPolicy();  
  }  
  
        @Bean  
  public DiscountPolicy fixDiscountPolicy() {  
            return new FixDiscountPolicy();  
  }  
    }  
  
}
```

- 실제 개발에서는 getBean 등을 활용할 필요가 없음

## 3. BeanFactory와 ApplicationContext

![](https://velog.velcdn.com/images%2Fwoply%2Fpost%2F10901a8c-f9b2-4a8a-93be-5319d45fe1e9%2Fimage.png)

### 3-1. BeanFactory

- 스프링 컨테이너의 최상위 인터페이스
- `스프링 빈을 관리하고 조회하는 역할` 담당
- `getBean()` 제공
- 지금까지 사용했던 대부분의 기능은 BeanFactory를 제공

### 3-2. ApplicationContext

- BeanFactory 기능을 모두 상속받아서 제공
- 빈을 관리하고 조회하고, `수 많은 부가기능`을 제공

** ApplicationContext가 제공하는 부가기능 **

![ApplicationContext가 제공하는 부가기능](https://velog.velcdn.com/images%2Fwoply%2Fpost%2F926d3c12-7700-4a25-b1f5-46c17bb25b02%2Fimage.png)

- 메시지 소스를 활용한 국제화 기능
		- ex) 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력

- 환경변수
		- 로컬, 개발, 운영 등을 구분해서 처리

- 어플리케이션 이벤트
		- 이벤트를 발행하고 구독하는 모델을 편리하게 지원

- 편리한 리소스 조회
		- 파일, 클래스패스, 외부 url 등에서 리소스를 편리하게 조회

`BeanFactory를 직접 사용할 일은 거의 없고, 부가기능이 포함된 ApplicationContext를 사용`
`BeanFactory나 ApplicationContext를 스프링 컨테이너라고 함`

## 4. 다양한 설정 형식 지원 - 자바코드, XML

![다양한 설정 형식 지원 - 자바코드, XML](https://blog.kakaocdn.net/dn/b7eJZE/btroOEAjt5g/ivfaIX1k4G92wdsT9lxct0/img.png)

### 4-1. 어노테이션 기반 자바 코드 설정 사용

- `AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);`
- `AnnotationConfigApplicationContext` 클래스를 사용하면서 자바코드로 된 설정 정보를 넘기면 됨

### 4-2. XML 설정 사용

- `GenericXmlApplicationContext`를 사용하면서 `xml` 설정파일을 넘기면 됨
- `컴파일 없이 빈 설정 정보를 변경할 수 있다는 장점`이 존재

- main > resources > new > XML Configuration File > Spring Config 선택하여 xml 설정파일 만들 수 있음
```xml

<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">  
 <bean id="memberRepository" class="hello.core.member.MemoryMemberRepository"></bean>  
 <bean id="memberService" class="hello.core.member.MemberServiceImpl">  
 <constructor-arg name="memberRepository" ref="memberRepository"/>  
 </bean> <bean id="discountPolicy" class="hello.core.discount.RateDiscountPolicy"></bean>  
 <bean id="orderService" class="hello.core.order.OrderServiceImpl">  
 <constructor-arg name="discountPolicy" ref="discountPolicy"/>  
 <constructor-arg name="memberRepository" ref="memberRepository"/>  
 </bean></beans>
```

```java
package hello.core.xml;  
  
import hello.core.member.MemberService;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.GenericXmlApplicationContext;  
  
import static org.assertj.core.api.Assertions.assertThat;  
  
public class XmlAppContext {  
  
    @Test  
 @DisplayName("xml 구성정보 설정 방법 테스트")  
    void xmlAppContext(){  
        ApplicationContext ac = new GenericXmlApplicationContext("appConfig.xml");  
  MemberService memberService = ac.getBean("memberService",MemberService.class);  
  assertThat(memberService).isInstanceOf(MemberService.class);  
  
  }  
}
```

(테스트 결과)
```
08:42:10.588 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 4 bean definitions from class path resource [appConfig.xml]
08:42:10.591 [main] DEBUG org.springframework.context.support.GenericXmlApplicationContext - Refreshing org.springframework.context.support.GenericXmlApplicationContext@4310d43
08:42:10.629 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'memberRepository'
08:42:10.642 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'memberService'
08:42:10.659 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'discountPolicy'
08:42:10.660 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'orderService'
```


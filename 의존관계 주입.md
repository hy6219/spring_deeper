# 의존관계 주입

## 1. 다양한 의존관계 주입 방법

의존관계 주입 방법은 아래와 같이 크게 4 가지 방법이 존재

1️⃣ 생성자 주입
2️⃣ 수정자 주입(setter 주입)
3️⃣ 필드 주입
4️⃣ 일반 메서드 주입

### 1-1 . 생성자 주입

- `생성자를 통해서 의존관계를 주입받는 방법`
- `생성자 호출 시점`에 딱 1번만 호출되는 것이 보장됨
- ** 불변, 필수 ** 의존관계에 사용
```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
  //  private final MemberRepository memberRepository = new MemoryMemberRepository();  
  private final MemberRepository memberRepository;  
    //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();  
 // private final DiscountPolicy discountPolicy = new RateDiscountPolicy();//정액할인제->정률할인제 (클래스만 갈아끼우면 됨!!)  
  private final DiscountPolicy discountPolicy;//인터페이스에만 의존하도록 변경  
  //-> '누군가' 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현객체를 대신 생성하고 주입해주어야 함  
  //어떤 구현체가 할당될 지는 어플리케이션이 할당해주어야 함(관심사 분리)  
  
 //=>app config를 통해서 추상화되었고, 구현을 모르는 상태라서 DIP가 지켜짐  
  //appconfig를 통해서 클라이언트는 확장에 열려있고(기능 추가 / 수정 ok), 변경(해당 기능을 활용하는 코드를 변경)에는 닫혀 있음 --> OCP 만족  
  
  @Autowired  
  public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
    ...
    }
```
"불변"은 아래와 같이 setter를 public으로 두었을때, 서비스 중 속성변경이 발생함으로써 버그가 발생할 수 있는 상황에서 중요하다!

```java
public void setDiscountPolicy(DiscountPolicy discountPolicy){
	this.discountPolicy = discountPolicy;
	}
```

"필수"는 생성자에서 왠만하면 값이 들어와야 함을 의미하기 때문에 중요!

❤ `생성자가 1개만 존재하는 경우`, "(1)" 과 "(2)"는 같은 의미이다!
즉, `@Autowired` 가 생략될 수 있다

(1)
```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
  //  private final MemberRepository memberRepository = new MemoryMemberRepository();  
  private final MemberRepository memberRepository;  
    //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();  
 // private final DiscountPolicy discountPolicy = new RateDiscountPolicy();//정액할인제->정률할인제 (클래스만 갈아끼우면 됨!!)  
  private final DiscountPolicy discountPolicy;//인터페이스에만 의존하도록 변경  
  //-> '누군가' 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현객체를 대신 생성하고 주입해주어야 함  
  //어떤 구현체가 할당될 지는 어플리케이션이 할당해주어야 함(관심사 분리)  
  
 //=>app config를 통해서 추상화되었고, 구현을 모르는 상태라서 DIP가 지켜짐  
  //appconfig를 통해서 클라이언트는 확장에 열려있고(기능 추가 / 수정 ok), 변경(해당 기능을 활용하는 코드를 변경)에는 닫혀 있음 --> OCP 만족  
  
  @Autowired  
  public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
```

(2)
```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
  //  private final MemberRepository memberRepository = new MemoryMemberRepository();  
  private final MemberRepository memberRepository;  
    //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();  
 // private final DiscountPolicy discountPolicy = new RateDiscountPolicy();//정액할인제->정률할인제 (클래스만 갈아끼우면 됨!!)  
  private final DiscountPolicy discountPolicy;//인터페이스에만 의존하도록 변경  
  //-> '누군가' 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현객체를 대신 생성하고 주입해주어야 함  
  //어떤 구현체가 할당될 지는 어플리케이션이 할당해주어야 함(관심사 분리)  
  
 //=>app config를 통해서 추상화되었고, 구현을 모르는 상태라서 DIP가 지켜짐  
  //appconfig를 통해서 클라이언트는 확장에 열려있고(기능 추가 / 수정 ok), 변경(해당 기능을 활용하는 코드를 변경)에는 닫혀 있음 --> OCP 만족  

  public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
```

### 1-2. 수정자(setter) 주입

- ** 선택, 변경 ** 가능성이 있는 의존관계에 사용 ◀ 파라미터값이 없어도 됨 (<- `@Autowired(required = false)` 를 지정해주면 주입할 대상이 없어도 동작 가능)
- 자바빈 프로퍼티 규약의 수정자 메서드 방식(수정자는 set필드명)을 사용하는 방식

```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
  //  private final MemberRepository memberRepository = new MemoryMemberRepository();  
  private MemberRepository memberRepository;  
    //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();  
 // private final DiscountPolicy discountPolicy = new RateDiscountPolicy();//정액할인제->정률할인제 (클래스만 갈아끼우면 됨!!)  
  private DiscountPolicy discountPolicy;//인터페이스에만 의존하도록 변경  
  //-> '누군가' 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현객체를 대신 생성하고 주입해주어야 함  
  //어떤 구현체가 할당될 지는 어플리케이션이 할당해주어야 함(관심사 분리)  
  
 //=>app config를 통해서 추상화되었고, 구현을 모르는 상태라서 DIP가 지켜짐  
  //appconfig를 통해서 클라이언트는 확장에 열려있고(기능 추가 / 수정 ok), 변경(해당 기능을 활용하는 코드를 변경)에는 닫혀 있음 --> OCP 만족  
  
  
  @Autowired  
  public void setMemberRepository(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
    }  
  
    @Autowired  
  public void setDiscountPolicy(DiscountPolicy discountPolicy) {  
        this.discountPolicy = discountPolicy;  
    }
```
```java
@Test  
@DisplayName("수정자 주입")  
void setterDiTest() {  
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class);  
    assertDoesNotThrow(() -> ac.getBean(OrderServiceImpl.class));  
}
```

```
23:53:39.123 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'orderServiceImpl'
[setter di]memberRepository= hello.core.member.MemoryMemberRepository@cb191ca
[setter di]discountPolicy= hello.core.discount.RateDiscountPolicy@a776e
```

✅ 대략적인 순서 

- 스프링 빈 주입 > 의존관계 주입
- 생성자 주입방식은 스프링 빈 주입 단계에서 일어남
- 수정자 주입방식은 의존관계 주입 단계에서 일어남

### 1-3. 필드 주입

- 필드에 바로 주입해주는 방식
- 코드가 간결하지만, 외부에서의 변경이 불가능해서 순수 자바로 테스트하기 힘들다는 치명적인 단점이 존재
- 인텔리제이에서도 "Field injection is not recommended "를 띄워주는 안티패턴

```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
  @Autowired private MemberRepository memberRepository;  
  @Autowired private DiscountPolicy discountPolicy;
```

```java
@Test  
@DisplayName("필드 주입 단점 - 외부에서 변경이 어려움")  
void fieldDiWeaknessTest(){  
    OrderServiceImpl orderService = new OrderServiceImpl();  
    orderService.createOrder(1L,"itemA", 10000);  
}
```
위의 경우, 외부에서 필드에 접근할 수 없어서, NullPointerException 이 발생한다
▶ 수정자를 만들어야만 함
▶ 그럴바에는, 차라리 수정자주입을 해주는 것이 더 나을 것
▶ DI 프레임워크가 없으면 외부에서 아무것도 할 수가 없음

- 애플리케이션의 실제코드와 관계없는 테스트 코드 or 스프링 설정과 관련된 `@Configuration` 같은 곳에서만 특별한 용도로만 사용


### 1-4. 일반 메서드 주입

- 일반 메서드를 통해서 의존관계를 주입받을 수 있음
- `한 번에 여러 필드를 주입받을 수 있음`
- 일반적으로 잘 사용하지 않음

```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
  private MemberRepository memberRepository;  

  private DiscountPolicy discountPolicy;
  
  @Autowired  
  public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy){  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
```

- 의존관계 자동주입은 `스프링 컨테이너가 관리하는 빈이어야 동작! 일반 자바 객체에서는 동작x!`
(예외- 바이트 코드 조작을 통해 자바 객체도 의존관계 자동주입을 해줄 수 있다고 한다)


## 2. 옵션 처리

특정 객체를 스프링 빈으로 등록하지 않아도 정상동작할 수 있도록 처리하기 위함
그러나 `@Autowired`의 `required` 옵션의 기본값이 `true` 이기 때문에 자동주입 대상이 없으면 오류발생

<처리 방법>

- `@Autowired(required = false)` : 자동주입할 대상이 없으면 setter 메서드 호출이 안됨
- `org.springframework.lang.@Nullable` : 자동주입할 대상이 없으면 null이 입력됨
- `Optional<>` : 자동주입할 대상이 없으면 Optional.empty가 입력됨

```java
package hello.core.autowired;  
  
import hello.core.member.Member;  
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
import org.springframework.lang.Nullable;  
  
import java.util.Optional;  
  
public class AutowiredTest {  
    @Test  
  void autowiredOption(){  
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class);  
  
    }  
  
    static class TestBean{  
        @Autowired(required = false)  
        public void setBean1(Member noBean1){  
            System.out.println("no bean1= "+noBean1);  
        }  
  
        @Autowired  
  public void setBean2(@Nullable Member noBean2){  
            System.out.println("noBean2 = " + noBean2);  
        }  
  
        @Autowired  
  public void setBean3(Optional<Member> noBean3){  
            System.out.println("noBean3 = " + noBean3);  
        }  
    }  
}
```

```
08:04:48.945 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'autowiredTest.TestBean'
noBean2 = null
noBean3 = Optional.empty

Process finished with exit code 0

```

▶ `@Autowired(required = false)`이 붙은 수정자는 호출조차 안되고 있음을 확인

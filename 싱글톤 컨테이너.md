# 싱글톤 컨테이너

- 객체 인스턴스가 JVM 내에 딱 1개만 존재해야 하는 것

## 1. 웹 애플리케이션과 싱글톤

![](https://images.velog.io/images/hyun6ik/post/4f50bf29-493e-4ff7-9e21-3453a04ca04f/image.png)

- 스프링은 기업용 온라인 서비스 제공을 위해 탄생
- 위와 같이 싱글톤으로 관리되지 않는 경우, 고객의 요청이 들어올 때마다 매번 서비스 객체를 만들게 되는 비효율적인 면이 발생됨(AppConfig를 참고해보면, 레포지토리까지 만들어지게 될 것)

▶ ** 메모리 낭비가 심함 **

((SOLUTION)) `해당 객체가 딱 1개만 생성되고, 공유하도록 싱글톤 패턴으로 설계`

** 스프링 없는 순수 DI 컨테이너 테스트 **
```java
package hello.core.singleton;  
  
import hello.core.AppConfig;  
import hello.core.member.MemberService;  
import org.assertj.core.api.Assertions;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
  
import static org.assertj.core.api.Assertions.assertThat;  
  
public class SingletonTest {  
  
    @Test  
 @DisplayName("스프링 없는 순수한 DI 컨테이너")  
    void pureContainer(){  
        AppConfig appConfig = new AppConfig();  
        //1. 조회 : 호출할 때마다 객체를 생성  
  MemberService memberService1 = appConfig.memberService();  
        //2. 조회 : 호출할 때마다 객체를 생성  
  MemberService memberService2 = appConfig.memberService();  
        System.out.println("memberService1= "+memberService1);  
        System.out.println("memberService2= "+memberService2);  
        //참조값이 다른것을 확인  
        assertThat(memberService1).isNotSameAs(memberService2);  
    }  
  
}
```

## 2. 싱글톤 패턴

- `클래스의 인스턴스가 딱 1개만 생성되는 것을 보장`하는 디자인 패턴
- 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 함 ▶ `private 생성자`를 사용해서 외부에서 함부로 new 키워드를 사용하지 못하도록 막아야 함

```java
package hello.core.singleton;  
  
public class SingletonService {  
  
    //JVM 로딩 시 자기자신이 생성됨  
  private static final SingletonService instance = new SingletonService();  
  
    //조회시 사용  
  public static SingletonService getInstance(){  
        return instance;  
    }  
  
    //외부 접근을 막음  
  private SingletonService(){  
  
    }  
  
    public void logic(){  
        System.out.println("싱글톤 객체 로직 호출");  
    }  
}
```

1. static 영역에 instance 객체를 미리 하나 생성해서 올려둠
2. 이 instance 가 필요하면 `getInstance()` 메서드를 통해서만 조회 가능(이 메서드를 통해 항상 같은 SingletonService 인스턴스 조회 가능)
3. 딱 1개의 인스턴스만 조회해야 하므로, 생성자를 private 으로 막아서 외부에서 new 키워드로 객체가 매번 생성되는 것을 막기

```java
@Test  
@DisplayName("싱글톤 패턴을 적용한 객체 사용")  
void singletonServiceTest(){  
    //SingletonService() has private access in  hello.core.singleton.SingletonService  
  SingletonService singletonService1 = SingletonService.getInstance();  
    SingletonService singletonService2 = SingletonService.getInstance();  
  
    System.out.println("singletonService1 = "+singletonService1);  
    System.out.println("singletonService2 = "+singletonService2);  
  
    assertThat(singletonService1).isSameAs(singletonService2);  
}
```

** 싱글톤 패턴의 문제점 **

- 구현코드 자체가 많이 들어감
- 의존관계상 클라이언트가 구체 클래스에 의존 ▶ DIP 위반
- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높음
- 테스트하기 어려움 ( getInstance로 객체를 지정해서 가져와야 함 )
- 내부 속성을 변경하거나 초기화하기 어려움
- private 생성자로 자식 클래스를 만들기 어려움
- 결론적으로 `유연성이 떨어짐`
- `안티패턴`으로 불리기도 함

## 3. 싱글톤 컨테이너

- 싱글톤 패턴의 문제점을 해결 + 객체 인스턴스를 싱글톤으로 관리
- 스프링 빈 = 싱글톤으로 관리되는 빈

** 싱글톤 컨테이너 **

- 싱글톤 패턴을 적용하지 않아도,  객체 인스턴스를 싱글톤으로 관리
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 수행 ▶ 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지 가능
		- 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 됨 ✨✨✨
		- DIP, OCP 원칙 지킴
		- 테스트 유연성 확보
		- private 생성자로부터 자유롭게 싱글톤 사용 가능
- `싱글톤 레지스트리` : 싱글톤 객체를 생성하고 관리하는 기능

```java
 @Test  
 @DisplayName("스프링 컨테이너와 싱글톤")  
    void springContainer() {  
        //AppConfig appConfig = new AppConfig();  
  AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);  
        //1. 조회 : 호출할 때마다 객체를 생성  
  MemberService memberService1 = ac.getBean("memberService", MemberService.class);  
        //2. 조회 : 호출할 때마다 객체를 생성  
  MemberService memberService2 = ac.getBean("memberService", MemberService.class);  
        System.out.println("memberService1= " + memberService1);  
        System.out.println("memberService2= " + memberService2);  
        //참조값이 같은것을 확인  
  /*  
 memberService1= hello.core.member.MemberServiceImpl@4bff64c2

memberService2= hello.core.member.MemberServiceImpl@4bff64c2  
 */  assertThat(memberService1).isSameAs(memberService2);  
    }
```
▶ 싱글톤 컨테이너 적용 후
![](https://velog.velcdn.com/images%2Fsyleemk%2Fpost%2Fb0c31f8b-8332-4389-af62-f7e26ccf1ce4%2Fimage.png)

- 스프링 컨테이너 덕분에 고객의 요청이 올때마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있게 됨

🧠 스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것이 아니라, `요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공` ( ∝ 빈 스코프 )

	- ex ) http 세션과 동일한 생명주기를 갖도록 만드는 경우
	- ex ) 고객이 들어올때 만들고, 고객이 나갈때 생명주기를 끝내는 경우



## 4. 싱글톤 방식의 주의점

- 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에, `싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안됨` ! `무상태(stateless)로 설계해야 함`
		- 특정 클라이언트에 의존적인 필드가 있어서는 안됨
		- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됨
		- 가급적 읽기만 가능해야 함
		- ** 공유 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 함 **
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있음
```java
package hello.core.singleton;  
  
public class StatefulService {  
    private int price;//상태를 유지하는 필드  
  
  public void order(String name, int price){  
        System.out.println("name = "+name+", price="+price);  
        this.price = price;//여기가 문제!  
  }  
    public int getPrice(){  
        return this.price;  
    }  
}
```

```java
package hello.core.singleton;  
  
import org.assertj.core.api.Assertions;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
import org.springframework.context.annotation.Bean;  
  
public class StatefulServiceTest {  
  
    @Test  
 @DisplayName("싱글톤 방식의 문제점 - 상태 유지 시 문제")  
    void statefulServiceSingletonTest() {  
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);  
        StatefulService statefulService1 = ac.getBean(StatefulService.class);  
        StatefulService statefulService2 = ac.getBean(StatefulService.class);  
  
        //ThreadA: A 사용자가 10000원 주문  
  statefulService1.order("userA", 10000);  
        //ThreadB : B 사용자가 20000원 주문  
  statefulService2.order("userB", 20000);  
  
        //ThreadA: 사용자A 주문 금액 조회  
  int price1 = statefulService1.getPrice();  
        System.out.println("price1= " + price1);//사용자A 이후 사용자B가 값을 변경하도록 변경요청해서 20000원으로 조회됨  
  Assertions.assertThat(price1).isEqualTo(20000);  
    }  
  
    static class TestConfig {  
        @Bean  
  public StatefulService statefulService() {  
            return new StatefulService();  
        }  
    }  
}
```

위와 같이 같은 인스턴스가 공유되고 있는데, 다른 사용자가 다른 값을 요청하는 경우가 발생되면, 각 사용자의 요청값에 대한  대응이 예상값과 달라지는 현상이 발생됨

(Solution)
```java
package hello.core.singleton;  
  
public class StatelessService {  
  
    public int order(String name, int price){  
        System.out.println("name = "+name+", price= "+price);  
        return price;  
    }  
  
}
```
```java
package hello.core.singleton;  
  
import org.assertj.core.api.Assertions;  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
import org.springframework.context.annotation.Bean;  
  
import static org.junit.jupiter.api.Assertions.*;  
  
class StatelessServiceTest {  
  
    @Test  
 @DisplayName("무상태로 설계")  
    void statelessServiceTest(){  
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);  
        StatelessService statelessService1 = ac.getBean(StatelessService.class);  
        StatelessService statelessService2 = ac.getBean(StatelessService.class);  
  
        int userAPrice = statelessService1.order("userA",10000);  
        int userBPrice = statelessService2.order("userB", 20000);  
  
        Assertions.assertThat(userAPrice).isEqualTo(10000);  
        Assertions.assertThat(userBPrice).isEqualTo(20000);  
    }  
  
    static class TestConfig{  
        @Bean  
  public StatelessService statelessService(){  
            return new StatelessService();  
        }  
    }  
  
}
```


    
